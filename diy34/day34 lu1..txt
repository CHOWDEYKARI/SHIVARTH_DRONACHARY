Untitled Note
2023-03-25_15h36

#shiva#
Stop
You we are going to talk about sorting we are going to learn sorting and its types and finally we are going to conclude let's look at by the end of this learning unit you will be able to implement bubble sort selection sort and insertion sword you will be able to demonstrate the best sorting algorithm for a problem what is sorting and why do we need it assorting algorithm is used to rearrange a given array Or List elements according to a comparison operator on the elements the comparison operator is used to decide the New Order of the element in the respective data structure for example if we were to arrange a jumbled list of words and before sorting that input
And then let him know how you want to do
Is provided to an algorithm after the Sorting is applied the list of words
to talk to
Should be in an order it may be ascending or
I wish I didn't
Descending but it has to be in an arranged order so that's what sorting refers
Care today I
To
Management of data in a preferred order is called sorting it can be done either in ascending or
So
Descending orders the most common example of sorting is arranging the words in alphabetical or
The Sorting has many different types it depends on the technique used to sort the given input data we can have Bubble salt we can have selection sort we can have merge sort we can have insertion sort we can also have quick sort these are most widely used sorting techniques which we use in our algorithms bubble sword let's have a look at it we will discuss the bubble sort algorithm the working procedure of bubble sort is simplest bubble so it works on the repeatedly swapping off adjacent elements until they are not in the intended order that is the underlying principle of bubble salt it is called Bubble sword because the
Of every elements is just like the movement of air bubbles in the water bubbles in the water rise up to the surface similarly the array elements in bubble sort move to the end in each iteration although it is simple to use it is primarily used as an educational tool because the performance of bubble sort is poor in the real world scenario it is not suitable for large data sets the average and worst case complexity of bubble salt is oh and square where n is the number of items on the input items to the Salt so let's look at the working of bubble shot the algorithm where we provide an input of the jumbled numbers in this one let's consider an array of an elements whereas the assumed function which is going to smoke the elements in the algorithms will be able to swap one element at a time which means we
You run this algorithm in number of passes so when we see the working of bubble sort algorithms we have taken this unsorted array for the first pass sorting will start from the initial to elements that is 6 and 2 in the first pass let's compare them to check which one is greater since 6 is greater than 2 hence the position of six and two will be swapped with each other and in the next iteration we see that two comes before 6:00 and hence we move to the next two letters that is six and five in this two numbers five is smaller than six so the position of five and six will be swapped again and this process will continue until unless the last digit is the one which is the biggest number similarly the moment we start the second pass the first two digits are fine and hence we move on to the next two digits here we see that between
5 and 33 is smaller and 5 is bigger so 3 and 5 will be swapped the moment this happens we move on to the next section where 5 and 6 and we see that 6 is bigger than 5 which is fine and we do not do anything similarly it moves on to the last two pair six and nine whereas 9 is bigger and hence we again do not do anything and we move on to the third pass in the third past the same process will be followed for the third iteration We compare between two and three and nothing needs to be done and hence it moves to the next iteration where we see that three and five it is fine and hence we move to the next iteration and finally again we see that five and six again this is arrange absolutely fine and we need not to do anything similarly up to end whenever this is exhausted finally we get a sorted Arabia the first element is the smallest and the last element is the biggest element if you notice the output at the end of the second pass
Third bus it's exactly similar but the third pass was necessary to ensure that the array is sorted that's why the performance of the bubble sort is not very great it is good for educational purposes but it's not a practical approach since it takes huge amount of time in the average case and the worst case it takes oh and square as the time complexity and in the best case it takes o of n again which is very very rare the best case complexity it occurs when there is no sorting required that is array is already sorted and this happens very rare average case complexity it occurs when the array elements are in jumbled order that is not properly ascending and not properly descending the average case time complexity of bubble salt is on Square first case complexity it occurs when the array elements are required to be sorted in reverse order that means suppose you have to sort the array elements in ascending order but it elements are
order and again worst case complexity of bubble sort is on Square so let's look at the implementation of bubble sort in order to implement bubble sort we take an array 6253 and 9 and we take the n as length of the array we write a function bubble saw to which we pass this array and the number of elements of an array we start with the outer for Loop in the after for Loop we start from 0 element up to n minus 1 then for the inner for Loop we start
Come on here again
From J equal to 0 and J less than N - 1 and J + + at each step we do a comparison whether the current element is greater than the next element in the same sequence if that is the case we take a temp variable and we swap these elements with the help of a temp variable where the element
The jet position is given to Temp and the element
Is
On J + 1/8 position is given to the jet position and finally the temp is assigned to J + 1 its position with this swapping we are able to swap to digits and this process keeps on continuing inside the nested for Loop and the moment we get the output and
What about tomorrow the.
This is how the output looks like the complexity of average and worst case is open Square which is not very great let's look at another approach known as the selection sort selection sort is the next algorithm which we are going to study in the Sorting so sorting as we saw can be of multiple types and selection sort is the one which defines repeatedly the Minima and maximum element in and given set of input the working procedure of selection sort is also simple in selection sword this smallest value among the unsorted elements of the array is selected in every pass and inserted to its appropriate position into the
It is also the simplest algorithm it is an In-Place comparison sorting algorithm in this algorithm array is divided into two parts first is the sorted part and another one is the unsorted part initially the sorted part of the array is empty and unsorted part is given array sorted part is placed at the left while the unsorted part is placed to the right in the selection sort the first smallest element is selected from the unsorted array and placed at the first position after the second smallest element is selected and placed in the second position the process continues until the entire array is sorted completely the average and worst time complexity of selection sort is also and square where n is the number of items due to this it is not suitable for large data sets so let's look at the working here we have an unsorted set of inputs wherein we start with the first pass in the first pass
Start comparing between 6 and 2 and we see that they must be reversed then again we compare between two and five and hence we see that the position of 2 and 5 is fine the position of 5 and 6 is checked by looking into the position of 5 and 6 we need to swap them similarly this process continues with rest of the numbers and this is how in the first pass we are able to partially sort the array then we start in the second pass and we start from the second number by leaving the first element and we start this comparison from the second element till we reach to the end of the array and then again this is partially sorted we move on to the third for us in the third pass we start from the third element leaving the first and second element and this process keeps on continuing until the entire array is sorted if we look at the implementation of selection is kind of similar the only difference
The previous starting algorithm is that in this one we just need to leave the first few elements in the array which are already sorted as we move from one pass to another pass hence is exactly similar only difference is going to be inside the inner for Loop where the J starts from I + 1 living behind the previous Elements which are already considered to be sorted the first part of the array and hence we swap it if the next element is greater than the previous element if we give an input and after sorting the output is completely sorted but because of the complexity involved it is not a suitable approach next let's look at another sorting algorithm known as insertion short insertion short is another sorting Paradigm the working procedure of insertions what is also simple insertion salt Works similar to sorting off playing cards in hands it is assumed that the first card is already sorted in the card game and then we select
unsorted card if the selected unsorted card is greater than the first card it will be placed at the right side otherwise it will be placed at the left side similarly all unsorted cards are taken and put in their exact place the same approach is applied in insertion short the idea behind insertion sort is that first take one element it through the sorted array although it is simple to use it is not appropriate for large data sets at the time complexity for insertion sort is the average
kiss and first
But of items insertion sort is less efficient than other sorting algorithms which we are going to study next let's look at the working of insertion sort there are various steps involved Step 1 is the element is the first element assume that it is already sorted then you pick the next element as a step 2 and store it separately step 3 now compare the key with all the elements in the sorted array step 4 if the element is the sorted array in smaller than the current element then move to the next element as shift greater elements in the area towards the right step 5 is to insert the value step 6 is to repeat until the array is completely sorted so that is how it works implementation of insertion salt again takes NE.
Complexity of old Square be given input of an unsorted array and in the insertion sort function we start with an outer for Loop and we assign the first element to a temp variable to that with only do the insertion only if it satisfies the condition where the element to the next of it is greater than the previous one and hence we only do the insertion and after sorting we get the sorted array if we compare the best average worst complexities along with space complexities and stabilities of bubble sort selection sort and insertion salt the best time complexity of bubble sort and insertion salt r o n whereas selection sort s o n Square average time complexity of all these algorithms are oh and square which is not very great for large data sets similarly first time complexity is also on Square again not suitable for larger data sets space complexity is one for all of them and bubble sort and in
Are considered to be stable whereas selection shot is not considered to be stable in this module we learned about bubble sort working of bubble salt selection sword working of selection sort insertion sort and the comparison between all of them in this learning.
imp
Salon
